PREGUNTA 53

	(1) ps
	(2) ./es1 > /dev/pts/17
	(3) ./es1 | ./es1
	(4) fitxer es1_v2.c
	(5) strace -o salida_v2 -e read ./es1_v2 < es2.c
		strace -o salida_v1 -e read ./es1 < es2.c
	#

	Diferencias: 
		V1:
			read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\t\2\0\0\0\0\0"..., 832) = 832
			read(0, "#", 1)                         = 1
			read(0, "i", 1)                         = 1
			read(0, "n", 1)                         = 1
			read(0, "c", 1)                         = 1
			read(0, "l", 1)                         = 1
			read(0, "u", 1)                         = 1
			read(0, "d", 1)                         = 1
			read(0, "e", 1)                         = 1
			read(0, " ", 1)                         = 1
			...
			read(0, "", 1)                          = 0
			+++ exited with 0 +++
		#

		V2:
			read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\t\2\0\0\0\0\0"..., 832) = 832
			read(0, "#include <string.h>\n#include <st"..., 1024) = 1024
			read(0, "(time(NULL));\n\tc='\\n';\n\tfor(i=0;"..., 1024) = 394
			read(0, "", 1024)                       = 0
			+++ exited with 0 +++
		#
	#

	Llamadas al sistema read:
		V1:
			Tantes com chars a l'entrada + 1 (el primer).
		#
		V2:
			4.
		#
	#

	Rendiment:
		V2 tindrà més bon rendiment que V1 ja que només fa 4 crides al sistema.
		Com més crides al sistema, més es triga. (kernel ha de rebre-la i posar-se a executar-la).
	#
#


PREGUNTA 54

	Amb '0':
		A la terminal: 
			./es2 0 3 > sortida_es2_0
			............................
			Si argv[1]==0 escribiremos los numero en ascii, sino en formato interno (int)
			............................
		#
		A sortida_es2_0:
			1059301233
			81921963
			2016303992
		#
	#

	Amb '1':
		A la terminal: 
			./es2 1 3 > sortida_es2_1
			............................
			Si argv[1]==0 escribiremos los numero en ascii, sino en formato interno (int)
			............................
		#
		A sortida_es2_1:
			Þ®~v
			ºŠ
			sîR
		#
	#

	La diferència entre posar 0 o 1, és que amb 0, llegeixes chars i escrius chars.
	En canvi, amb 1, llegeixes ints i escrius chars. Per aquesta raó surten chars que no tenen sentit.
#

PREGUNTA 55

	Comando:  ./es3 < sortida_es2_1
	.............................................
	Este programa asume que los datos de entrada son: entero(en formato int=4bytes)+'\n'. Total 5 bytes por numero
	Una vez leido el numero lo convierte a ascii y lo saca por la salida std
	Para poder usarlo debes generar un fichero con el programa es2 , opcion 1, y redireccionar la entrada con ese fichero
	.............................................
	1988013790	<-	Þ®~v
	404261562	<-	ºŠ
	1391329907	<-	sîR

	Els converteix.
	En format 0, pren per ints l'entrada i els reconverteix a chars (ja eren chars -> no "vàlid")
#


PREGUNTA 56

	./es4 < sortida_es2_0
		.............................................
		Este programa asume que la entrada std son numeros en ascii (de longitud variable por lo tanto), seguidos de un caracter '\n' 
		Despues de leer el numero los escribe tal cual por la salida std en ascii tambien 
		Puedes usar la salida del programa es2 con la opcion 0
		.............................................
		1059301233
		81921963
		2016303992
	#

	./es4 < sortida_es2_1
		.............................................
		Este programa asume que la entrada std son numeros en ascii (de longitud variable por lo tanto), seguidos de un caracter '\n' 
		Despues de leer el numero los escribe tal cual por la salida std en ascii tambien 
		Puedes usar la salida del programa es2 con la opcion 0
		.............................................
		~v
		��
		s�R
	#

	El programa es4 interpreta la entrada en ascii por lo tanto hace la "inversa" del es3.

	La salida es diferente para cada programa porque interpreta de manera diferente los datos. Y la entrada es susceptible a como la interprete el programa ya que se pasa como un void*.
#
